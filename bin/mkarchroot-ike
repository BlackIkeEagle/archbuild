#!/bin/bash
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# Avoid any encoding problems
export LANG=C

# check if messages are to be printed using color
unset ALL_OFF BOLD BLUE GREEN RED YELLOW
if [[ -t 2 ]]; then
	# prefer terminal safe colored and bold text when tput is supported
	if tput setaf 0 &>/dev/null; then
		ALL_OFF="$(tput sgr0)"
		BOLD="$(tput bold)"
		BLUE="${BOLD}$(tput setaf 4)"
		GREEN="${BOLD}$(tput setaf 2)"
		RED="${BOLD}$(tput setaf 1)"
		YELLOW="${BOLD}$(tput setaf 3)"
	else
		ALL_OFF="\e[1;0m"
		BOLD="\e[1;1m"
		BLUE="${BOLD}\e[1;34m"
		GREEN="${BOLD}\e[1;32m"
		RED="${BOLD}\e[1;31m"
		YELLOW="${BOLD}\e[1;33m"
	fi
fi
readonly ALL_OFF BOLD BLUE GREEN RED YELLOW

plain() {
	local mesg=$1; shift
	printf "${BOLD}    ${mesg}${ALL_OFF}\n" "$@" >&2
}

msg() {
	local mesg=$1; shift
	printf "${GREEN}==>${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

msg2() {
	local mesg=$1; shift
	printf "${BLUE}  ->${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

warning() {
	local mesg=$1; shift
	printf "${YELLOW}==> WARNING:${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

error() {
	local mesg=$1; shift
	printf "${RED}==> ERROR:${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}

stat_busy() {
	local mesg=$1; shift
	printf "${GREEN}==>${ALL_OFF}${BOLD} ${mesg}...${ALL_OFF}" >&2
}

stat_done() {
	printf "${BOLD}done${ALL_OFF}\n" >&2
}

setup_workdir() {
	[[ -z $WORKDIR ]] && WORKDIR=$(mktemp -d --tmpdir "${0##*/}.XXXXXXXXXX")
}

cleanup() {
	[[ -n $WORKDIR ]] && rm -rf "$WORKDIR"
	[[ $1 ]] && exit $1
}

abort() {
	msg 'Aborting...'
	cleanup 0
}

trap_abort() {
	trap - EXIT INT QUIT TERM HUP
	abort
}

trap_exit() {
	trap - EXIT INT QUIT TERM HUP
	cleanup
}

die() {
	error "$*"
	cleanup 1
}

trap 'trap_abort' INT QUIT TERM HUP
trap 'trap_exit' EXIT

##
#  usage : in_array( $needle, $haystack )
# return : 0 - found
#          1 - not found
##
in_array() {
	local needle=$1; shift
	local item
	for item in "$@"; do
		[[ $item = $needle ]] && return 0 # Found
	done
	return 1 # Not Found
}

##
#  usage : get_full_version( [$pkgname] )
# return : full version spec, including epoch (if necessary), pkgver, pkgrel
##
get_full_version() {
	# set defaults if they weren't specified in buildfile
	pkgbase=${pkgbase:-${pkgname[0]}}
	epoch=${epoch:-0}
	if [[ -z $1 ]]; then
		if [[ $epoch ]] && (( ! $epoch )); then
			echo $pkgver-$pkgrel
		else
			echo $epoch:$pkgver-$pkgrel
		fi
	else
		for i in pkgver pkgrel epoch; do
			local indirect="${i}_override"
			eval $(declare -f package_$1 | sed -n "s/\(^[[:space:]]*$i=\)/${i}_override=/p")
			[[ -z ${!indirect} ]] && eval ${indirect}=\"${!i}\"
		done
		if (( ! $epoch_override )); then
			echo $pkgver_override-$pkgrel_override
		else
			echo $epoch_override:$pkgver_override-$pkgrel_override
		fi
	fi
}


CHROOT_VERSION='v2'

FORCE='n'
RUN=''
NOCOPY='n'

working_dir=''

APPNAME=$(basename "${0}")

# usage: usage <exitvalue>
usage() {
	echo "usage ${APPNAME} [options] working-dir [package-list | app]"
	echo ' options:'
	echo '    -r <app>      Run "app" within the context of the chroot'
	echo '    -u            Update the chroot via pacman'
	echo '    -f            Force overwrite of files in the working-dir'
	echo '    -C <file>     Location of a pacman config file'
	echo '    -M <file>     Location of a makepkg config file'
	echo '    -n            Do not copy config files into the chroot'
	echo '    -c <dir>      Set pacman cache'
	echo '    -h            This message'
	exit 1
}

while getopts 'r:ufnhC:M:c:' arg; do
	case "${arg}" in
		r) RUN="$OPTARG" ;;
		u) RUN='/bin/sh -c "pacman -Syu --noconfirm && (pacman -Qqu >/dev/null && pacman -Su --noconfirm || exit 0)"' ;;
		f) FORCE='y' ;;
		C) pac_conf="$OPTARG" ;;
		M) makepkg_conf="$OPTARG" ;;
		n) NOCOPY='y' ;;
		c) cache_dir="$OPTARG" ;;
		h|?) usage 0 ;;
		*) error "invalid argument '${arg}'"; usage ;;
	esac
done

if (( $EUID != 0 )); then
	die 'This script must be run as root.'
fi

shift $(($OPTIND - 1))

if [[ -z $RUN ]] && (( $# < 2 )); then
	die 'You must specify a directory and one or more packages.'
elif (( $# < 1 )); then
	die 'You must specify a directory.'
fi

working_dir="$(readlink -f ${1})"
shift 1

[[ -z $working_dir ]] && die 'Please specify a working directory.'

if [[ -z $cache_dir ]]; then
	cache_dirs=($(pacman -v $cache_conf 2>&1 | grep '^Cache Dirs:' | sed 's/Cache Dirs:\s*//g'))
else
	cache_dirs=(${cache_dir})
fi

host_mirror=$(pacman -Sddp extra/devtools 2>/dev/null | sed -E 's#(.*/)extra/os/.*#\1$repo/os/$arch#')
if echo "${host_mirror}" | grep -q 'file://'; then
	host_mirror_path=$(echo "${host_mirror}" | sed -E 's#file://(/.*)/\$repo/os/\$arch#\1#g')
fi

# {{{ functions
bind_mount() {
	local mode="${2:-rw}"
	local target="${working_dir}${1}"

	if [[ ! -e "$target" ]]; then
		if [[ -d "$1" ]]; then
			install -d "$target"
		else
			install -D /dev/null "$target"
		fi
	fi

	mount -o bind "$1" "$target"
	mount -o remount,${mode},bind "$target"
	mount --make-slave "$target"
}

chroot_mount() {
	trap 'trap_chroot_umount' EXIT INT QUIT TERM HUP

	bind_mount /sys ro

	[[ -e "${working_dir}/proc" ]] || mkdir "${working_dir}/proc"
	mount -t proc proc -o nosuid,noexec,nodev "${working_dir}/proc"
	bind_mount /proc/sys ro

	[[ -e "${working_dir}/dev" ]] || mkdir "${working_dir}/dev"
	mount -t tmpfs dev "${working_dir}/dev" -o mode=0755,size=10M,nosuid,strictatime
	mknod -m 666 "${working_dir}/dev/null" c 1 3
	mknod -m 666 "${working_dir}/dev/zero" c 1 5
	mknod -m 600 "${working_dir}/dev/console" c 5 1
	mknod -m 644 "${working_dir}/dev/random" c 1 8
	mknod -m 644 "${working_dir}/dev/urandom" c 1 9
	mknod -m 666 "${working_dir}/dev/tty" c 5 0
	mknod -m 666 "${working_dir}/dev/ptmx" c 5 2
	mknod -m 666 "${working_dir}/dev/tty0" c 4 0
	mknod -m 666 "${working_dir}/dev/full" c 1 7
	mknod -m 666 "${working_dir}/dev/rtc0" c 254 0
	ln -s /proc/kcore "${working_dir}/dev/core"
	ln -s /proc/self/fd "${working_dir}/dev/fd"
	ln -s /proc/self/fd/0 "${working_dir}/dev/stdin"
	ln -s /proc/self/fd/1 "${working_dir}/dev/stdout"
	ln -s /proc/self/fd/2 "${working_dir}/dev/stderr"

	[[ -e "${working_dir}/dev/shm" ]] || mkdir "${working_dir}/dev/shm"
	mount -t tmpfs shm "${working_dir}/dev/shm" -o nodev,nosuid,size=128M

	bind_mount /dev/pts

	[[ -e "${working_dir}/run" ]] || mkdir "${working_dir}/run"
	mount -t tmpfs tmpfs "${working_dir}/run" -o mode=0755,nodev,nosuid,strictatime,size=64M

	for host_config in resolv.conf localtime; do
		bind_mount /etc/$host_config ro
	done

	[[ -n $host_mirror_path ]] && bind_mount "$host_mirror_path" ro

	bind_mount "${cache_dirs[0]}"
	for cache_dir in ${cache_dirs[@]:1}; do
		bind_mount "$cache_dir" ro
	done
}

copy_hostconf () {
	cp -a /etc/pacman.d/gnupg "${working_dir}/etc/pacman.d"
	echo "Server = ${host_mirror}" > ${working_dir}/etc/pacman.d/mirrorlist

	if [[ -n $pac_conf && $NOCOPY = 'n' ]]; then
		cp ${pac_conf} ${working_dir}/etc/pacman.conf
	fi

	if [[ -n $makepkg_conf && $NOCOPY = 'n' ]]; then
		cp ${makepkg_conf} ${working_dir}/etc/makepkg.conf
	fi

	sed -r "s|^#?\\s*CacheDir.+|CacheDir = $(echo -n ${cache_dirs[@]})|g" -i ${working_dir}/etc/pacman.conf
}

trap_chroot_umount () {
	trap 'trap_abort' INT QUIT TERM HUP
	trap 'trap_exit' EXIT

	for cache_dir in ${cache_dirs[@]}; do
		umount "${working_dir}/${cache_dir}"
	done
	[[ -n $host_mirror_path ]] && umount "${working_dir}/${host_mirror_path}"

	for host_config in resolv.conf localtime; do
		umount "${working_dir}/etc/${host_config}"
	done
	umount "${working_dir}/proc/sys"
	umount "${working_dir}/proc"
	umount "${working_dir}/sys"
	umount "${working_dir}/dev/pts"
	umount "${working_dir}/dev/shm"
	umount "${working_dir}/dev"
	umount "${working_dir}/run"
}

chroot_lock () {
	# Only reopen the FD if it wasn't handed to us
	if [[ $(readlink -f /dev/fd/9) != "${working_dir}.lock" ]]; then
	  exec 9>"${working_dir}.lock"
	fi

	# Lock the chroot. Take note of the FD number.
	if ! flock -n 9; then
		stat_busy "Locking chroot"
		flock 9
		stat_done
	fi
}

chroot_run() {
	local dir=$1
	shift
	eval unshare -mui -- chroot "${dir}" ${@}
}

# }}}

umask 0022
if [[ -n $RUN ]]; then
	# run chroot {{{
	#Sanity check
	if [[ ! -f "${working_dir}/.arch-chroot" ]]; then
		die "'${working_dir}' does not appear to be a Arch chroot."
	elif [[ $(cat "${working_dir}/.arch-chroot") != ${CHROOT_VERSION} ]]; then
		die "'${working_dir}' is not compatible with ${APPNAME} version ${CHROOT_VERSION}. Please rebuild."
	fi

	chroot_lock
	chroot_mount
	copy_hostconf

	chroot_run "${working_dir}" ${RUN}

	# }}}
else
	# {{{ build chroot
	if [[ -e $working_dir && $FORCE = 'n' ]]; then
		die "Working directory '${working_dir}' already exists - try using -f"
	fi

	if { type -P btrfs && btrfs subvolume create "${working_dir}"; } &>/dev/null; then
		chmod 0755 "${working_dir}"
	fi

	chroot_lock
	chroot_mount

	pacargs="${cache_dirs[@]/#/--cachedir=}"
	if [[ -n $pac_conf ]]; then
		pacargs="$pacargs --config=${pac_conf}"
	fi

	if (( $# != 0 )); then
		if [[ $FORCE = 'y' ]]; then
			pacargs="$pacargs --force"
		fi
		if ! pacstrap -GMcd "${working_dir}" ${pacargs} $@; then
			die 'Failed to install all packages'
		fi
	fi

	if [[ -d "${working_dir}/lib/modules" ]]; then
		chroot_run "${working_dir}" ldconfig
	fi

	if [[ -e "${working_dir}/etc/locale.gen" ]]; then
		sed -i 's@^#\(en_US\|de_DE\)\(\.UTF-8\)@\1\2@' "${working_dir}/etc/locale.gen"
		chroot_run "${working_dir}" locale-gen
	fi
	echo 'LANG=C' > "${working_dir}/etc/locale.conf"

	copy_hostconf

	echo "${CHROOT_VERSION}" > "${working_dir}/.arch-chroot"
	# }}}
fi
